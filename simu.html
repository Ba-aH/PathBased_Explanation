<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>

<head>
    <title>Accueil</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* ----------- RESET & BASE ----------- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f7f9fc;
            color: #333;
            height: 100vh;
            overflow: hidden;
            font-size: 15px;
        }

        /* ----------- NAVIGATION ----------- */
        #nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 28px;
            background-color: #fff;
            border-bottom: 1px solid #e5e5e5;
            font-size: 18px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
        }

        #nav-bar a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s;
        }

        #nav-bar a:hover {
            color: #2f80ed;
        }

        /* ----------- LAYOUT PRINCIPAL ----------- */
        #content-area {
            display: flex;
            height: 100%;
        }

        /* ----------- PANNEAU DE CONTRÔLE (GAUCHE) ----------- */
        #left-panel {
            flex: 0 0 280px;
            background-color: #ffffff;
            border-right: 1px solid #eee;
            padding: 24px;
            overflow-y: auto;
            box-shadow: inset -1px 0 0 #eee;
        }

        #left-panel h3 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #444;
        }

        #left-panel label {
            display: block;
            margin-top: 16px;
            font-weight: 600;
            color: #555;
        }

        #left-panel input[type="text"],
        #left-panel select {
            width: 100%;
            padding: 10px 12px;
            margin-top: 6px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fdfdfd;
            transition: border 0.3s;
        }

        #left-panel input:focus,
        #left-panel select:focus {
            border-color: #A0C878;
            outline: none;
        }

        /* ----------- BOUTONS ----------- */
        .button {
            background-color: #749BC2;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 14px;
            width: 100%;
            margin-top: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.2s;
        }

        .button:hover {
            background-color: #4682A9;
            box-shadow: 0 2px 8px rgba(47, 128, 237, 0.3);
        }

        /* ----------- DROP ZONES POUR PRÉDICATS ----------- */
        #div1 {
            border: 2px dashed #bbb;
            border-radius: 8px;
            min-height: 80px;
            margin: 14px 0;
            padding: 12px;
            background-color: #fafbff;
            transition: border 0.3s;
        }

        #div1:hover {
            border-color: #2f80ed;
        }

        #listPredicats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        #listPredicats .predicat {
            padding: 6px 10px;
            background-color: #FFFBDE;
            color: #333;
            font-weight: bold;
            border-radius: 6px;
            border: 2px solid #ada56a;
            cursor: grab;
            font-size: 14px;
            user-select: none;
        }

        /* ----------- CENTRE : GRAPHE ----------- */
        .divQuestions {
            width: 100%;
            margin-top: 20px;
        }

        .divQuestions form>div {
            margin-bottom: 20px;
            /* espace entre les questions */
        }

        .radioOption {
            display: flex;
            align-items: center;
            margin: 4px 0;
            gap: 8px;
        }

        .graph-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .graph-controls .button {
            flex: 0 0 auto;
            width: auto;
            padding: 10px 16px;
        }

        .graph-controls input[type="text"] {
            flex: 1;
            min-width: 180px;
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        #center-panel {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            background-color: #f9f9fb;
        }

        #g_petit-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }

        .g {
            width: 100%;
            height: 600px;
            border: 3px solid #91C8E4;
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 2px 10px #FAF6E9;
        }

        .g_petit {
            width: 45%;
            height: 200px;
            display: flex;
            border: 3px solid #91C8E4;
            background-color: #f1f0e9;
            border-radius: 16px;
            box-shadow: 0 1px 6px #FAF6E9;
        }

        /* ----------- DROITE - EXPLICATION ----------- */
        #right-panel {
            flex: 0 0 300px;
            background-color: #ffffff;
            border-left: 1px solid #eee;
            padding: 24px;
            overflow-y: auto;
            box-shadow: inset 1px 0 0 #eee;
        }

        #right-panel h3 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #444;
        }

        #right-panel p {
            font-size: 14px;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        #right-panel h4 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #555;
        }

        #right-panel ul {
            list-style: none;
            padding-left: 0;
        }

        #right-panel li {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .legend-color {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 8px;
            border-radius: 50%;
        }

        .legend-color.blue {
            background-color: #3b82f6;
        }

        .legend-color.gray {
            background-color: #6c757d;
        }

        /* ----------- RESPONSIVE ----------- */
        @media (max-width: 1024px) {
            #content-area {
                flex-direction: column;
            }

            #left-panel,
            #right-panel {
                flex: none;
                width: 100%;
                border: none;
            }

            .g {
                height: 400px;
            }
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script>

        var color = "gray";
        let liste_node_click = [] // liste nodes cliqués
        let top5ChartInstance = null;
        let reponse_user_study = {} // liste des réponses user study
        let parent = {} // dictionnaire {node: parent de node}
        var len = undefined;
        var choix = "false"; // Choix = false --> utilisation graphe pondéré par défaut, choix = true --> utilisation graphe pondéré en fct des prédicats choisis par l'utilisateur
        var path = { nodes: [], edges: [] }; // chemin principal
        var path2 = { nodes: [], edges: [] }; // chemin principal avec ajout/remplacé par des petits chemins (mode ajout ou échanger)
        var data = { nodes: [], edges: [] }; // graphe
        var course = ""; // cours recommandé
        const container = document.getElementById("graph");
        let svg, nodeGroup, linkGroup, labelGroup; //------------------------------------------------------------------------------------
        const options = {
            interaction: {
                hover: true,
            },
            physics: {
                enabled: true,
                solver: "repulsion",
                "barnesHut": {
                    "springConstant": 0,
                    "avoidOverlap": 2
                },
                repulsion: {
                    springLength: 500,
                    springConstant: 0.05,  // la constante de ressort
                    nodeDistance: 1000,
                    damping: 0.09,
                },
            },
            nodes: {
                shape: "dot",
                size: 30,
                font: { size: 40, color: "#420f31" },
                borderWidth: 2,
            },
            edges: {
                arrows: {
                    to: { enabled: true, scaleFactor: 1 }  // flèche vers le nœud 'to'
                },
                width: 1,
                font: { size: 35, align: "top", color: "#420f31" },

            },
        };
        const liste_answer_possible = ['strongly agree', 'agree', 'neutre', 'disagree', 'strongly disagree'];
        const liste_question_possible = {
            '': ['This explanation lets me judge when I should trust the recommendation system.',
                'This explanation of how the recommendation system works has sufficient detail.',
                'This explanation of how the recommendation system works has irrelevant detail.'],
            'Based on the share of semantic attributes between the recommended movie and your interest in these semantic attributes :':
                ['This is a good recommendation',
                    'I will follow this course', 'I can determine how well I will like this course']
        }
        var path2_en_cours = false;
        var mode = "modeAjoutGraph";

        // -----------------FONCTIONS SIMPLES---------------//
        function resetChemin(network) { // utilisé dans : resetPath, ajouterGraph, echangerGraph
            data = {
                nodes: [...path.nodes],
                edges: [...path.edges]
            };
            network.setData(data);
            for (k of Object.keys(parent)) {
                parent[k] = null;
            }
            liste_node_click = []
            // Recentrer après reset
            network.fit({
                animation: true
            });
        }

        function orderNodesByEdges(nodes, edges) { // Permet d'afficher les petits chemins toujours dans le même ordre
            // Trouve le premier noeud (celui qui n'est pas dans 'to' d'une arête)
            const toNodes = new Set(edges.map(e => e.to));
            const fromNodes = new Set(edges.map(e => e.from));

            let startNode = nodes.find(n => !toNodes.has(n.id));
            if (!startNode) startNode = nodes[0]; // fallback

            const orderedNodes = [];
            let currentId = startNode.id;

            while (currentId !== undefined) {
                const currentNode = nodes.find(n => n.id === currentId);
                if (!currentNode) break;
                orderedNodes.push(currentNode);

                const nextEdge = edges.find(e => e.from === currentId);
                currentId = nextEdge ? nextEdge.to : undefined;
            }
            return orderedNodes;
        }



        function dragstartHandler(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
        }

        function dragoverHandler(ev) {
            if (ev.target.id == "div1" || ev.target.id == "listPredicats") {
                ev.preventDefault();
            }
        }

        function dropHandler(ev) {
            ev.preventDefault();
            const data3 = ev.dataTransfer.getData("text");
            ev.target.appendChild(document.getElementById(data3));
        }


        function getOrderOfData(listId) {

            //get the list
            var list = document.getElementById(listId);


            var orderArray = [];
            var childs = list.children;
            for (var i = 0; i < childs.length; i++) {
                var child = childs[i];
                orderArray.push(child.id);
            }

            return orderArray;
        }


        function chercherNode() { // button Chercher node
            const node = document.getElementById("node").value;
            console.log('node : ', node);
            for (n of data.nodes) {
                console.log('n :', n.label);
                if (n.label == node) {
                    const graph = window.graphPrincipal;
                    const width = +graph.svg.attr("width");
                    const height = +graph.svg.attr("height");
                    focusOnNode(graph, n.id, width, height);
                    //focusOnNode(graphe_svg, n.id, graphe_svg.attr("width"), graphe_svg.attr("height"));
                    return
                }


            }
            alert("Node non trouvé");
            return
        }

        //---------------------------------------------------------------------------------------------------------
        function drawGraph(container, nodesData, edgesData) {
            if (!container) {
                console.error("Élément #graph-container introuvable.")
                return
            }
            container.innerHTML = "";
            // Assure-toi que le conteneur a bien une taille
            const width = container.clientWidth || 600;
            const height = container.clientHeight || 400;


            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);


            const zoomGroup = svg.append("g").attr("class", "zoom-group");

            const linkGroup = zoomGroup.append("g").attr("class", "links");
            const nodeGroup = zoomGroup.append("g").attr("class", "nodes");
            const labelGroup = zoomGroup.append("g").attr("class", "labels");
            const edgeLabelGroup = zoomGroup.append("g").attr("class", "edge-labels");

            /*svg.call(d3.zoom().on("zoom", (event) => {
                zoomGroup.attr("transform", event.transform);
            }));*/
            const zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on("zoom", (event) => {
                    zoomGroup.attr("transform", event.transform);
                });

            svg.call(zoom);



            // Variables
            let simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                //.force("center", d3.forceCenter(+svg.attr("width") / 2, +svg.attr("height") / 2));
                .force("center", d3.forceCenter(+svg.attr("width") / 2, +svg.attr("height") / 2).strength(0.01));

            updateGraph(nodesData, edgesData, svg, linkGroup, nodeGroup, labelGroup, edgeLabelGroup, simulation, zoomGroup); // première update
            return { svg, linkGroup, nodeGroup, labelGroup, edgeLabelGroup, simulation, zoomGroup, zoom };
        }



        // function updateGraph(nodesData, edgesData) {
        //     let simulation = d3.forceSimulation()
        //         .force("link", d3.forceLink().id(d => d.id).distance(100))
        //         .force("charge", d3.forceManyBody().strength(-300))
        //         .force("center", d3.forceCenter(d3.forceCenter(+svg.attr("width") / 2, +svg.attr("height") / 2)));
        //     const edgesD3 = edgesData.map(e => ({
        //         ...e,
        //         source: e.from,
        //         target: e.to
        //     }));
        //     console.log("d3:", d3);
        //     // Met à jour la simulation
        //     nodesData.forEach(n => {
        //         if (n.x == null) n.x = Math.random() * +svg.attr("width");
        //         if (n.y == null) n.y = Math.random() * +svg.attr("height");
        //     });

        //     simulation.nodes(nodesData);
        //     simulation.force("link").links(edgesD3);

        //     console.log("Noeuds sans x ou y :", nodesData.filter(n => n.x === undefined || n.y === undefined));
        //     console.log("Liens avec source ou target undefined :", edgesData.filter(e => !e.from || !e.to));




        //     // Liens
        //     const linkSelection = linkGroup.selectAll("line")
        //         .data(edgesD3, d => d.id || (d.source.id + "-" + d.target.id))


        //     linkSelection.exit().remove();

        //     const linkEnter = linkSelection.enter()
        //         .append("line")
        //         .attr("stroke-width", 1.5)
        //         .attr("stroke", "#aaa");

        //     linkSelection.merge(linkEnter);

        //     // Noeuds
        //     const nodeSelection = nodeGroup.selectAll("circle")
        //         .data(nodesData, d => d.id);

        //     nodeSelection.exit().remove();

        //     const nodeEnter = nodeSelection.enter()
        //         .append("circle")
        //         .attr("r", 8)
        //         .attr("fill", d => d.group === 0 ? "orange" :
        //             d.group === 1 ? "yellow" :
        //                 d.group === 2 ? "red" :
        //                     d.group === 3 ? "blue" :
        //                         "lightgreen")
        //         .call(drag(simulation));

        //     nodeSelection.merge(nodeEnter);

        //     // Labels
        //     const labelSelection = labelGroup.selectAll("text")
        //         .data(nodesData, d => d.id);

        //     labelSelection.exit().remove();

        //     const labelEnter = labelSelection.enter()
        //         .append("text")
        //         .text(d => d.label)
        //         .attr("font-size", "10px")
        //         .attr("dx", 10)
        //         .attr("dy", 3);

        //     labelSelection.merge(labelEnter);

        //     // Redémarre la simulation
        //     simulation.alpha(1).restart();

        //     simulation.on("tick", () => {
        //         //console.log('linkGroup :',linkGroup);

        //         linkGroup.selectAll("line")

        //             .attr("x1", d => d.source.x)
        //             .attr("y1", d => d.source.y)
        //             .attr("x2", d => d.target.x)
        //             .attr("y2", d => d.target.y);

        //         nodeGroup.selectAll("circle")
        //             .attr("cx", d => d.x)
        //             .attr("cy", d => d.y);

        //         labelGroup.selectAll("text")
        //             .attr("x", d => d.x)
        //             .attr("y", d => d.y);
        //     });
        // }



        function updateGraph(nodesData, edgesData, svg, linkGroup, nodeGroup, labelGroup, edgeLabelGroup, simulation, zoomGroup) {
            /*linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();*/
            //-------------------------------------------------------------------------------???????????
            const edgesD3 = edgesData.map(e => ({
                ...e,
                source: e.from,
                target: e.to
            }));

            // Vérifier positions initiales
            nodesData.forEach(n => {
                if (n.x == null) n.x = Math.random() * +svg.attr("width");
                if (n.y == null) n.y = Math.random() * +svg.attr("height");
            });
            //-----------------???????????

            // Met à jour les données dans la simulation
            simulation.nodes(nodesData);
            simulation.force("link").links(edgesD3);
            simulation.alpha(1).restart();
            // <== IMPORTANT


            // Define zoom behavior
            /*const zoom = d3.zoom()
                .scaleExtent([0.5, 5]) // Min and max zoom scale
                .on("zoom", (event) => {
                    zoomGroup.attr("transform", event.transform);
                    console.log("zoom");

                });

            // Apply zoom behavior to the SVG
            svg.call(zoom);//?????????????????

*/

            // Liens
            const linkSelection = linkGroup.selectAll("line")
                .data(edgesD3, d => d.id || (d.source.id + "-" + d.target.id));

            linkSelection.exit().remove();

            const linkEnter = linkSelection.enter()
                .append("line")
                .attr("stroke-width", 1.5)
                .attr("stroke", "#aaa");

            const linkElements = linkEnter.merge(linkSelection);

            // Noeuds
            const nodeSelection = nodeGroup.selectAll("circle")
                .data(nodesData, d => d.id);

            nodeSelection.exit().remove();

            const nodeEnter = nodeSelection.enter()
                .append("circle")
                .attr("r", 8)
                .attr("fill", d => d.group === 0 ? "orange" :
                    d.group === 1 ? "yellow" :
                        d.group === 2 ? "red" :
                            d.group === 3 ? "blue" : "lightgreen")
                .call(drag(simulation));

            const nodeElements = nodeEnter.merge(nodeSelection);

            // Labels
            const labelSelection = labelGroup.selectAll("text")
                .data(nodesData, d => d.id);

            labelSelection.exit().remove();

            const labelEnter = labelSelection.enter()
                .append("text")
                .text(d => d.label)
                .attr("font-size", "10px")
                .attr("dx", 10)
                .attr("dy", 3);

            const labelElements = labelEnter.merge(labelSelection);


            // edge label

            // Labels pour les arêtes
            const edgeLabelSelection = edgeLabelGroup.selectAll("text")
                .data(edgesD3, d => d.id || (d.source.id + "-" + d.target.id));

            edgeLabelSelection.exit().remove();

            const edgeLabelEnter = edgeLabelSelection.enter()
                .append("text")
                .attr("font-size", "9px")
                .attr("fill", "#555")
                .attr("text-anchor", "middle")
                .text(d => d.label || ""); // ou une propriété d.label sur les arêtes

            const edgeLabelElements = edgeLabelEnter.merge(edgeLabelSelection);


            simulation.on("tick", () => {
                linkElements
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                nodeElements
                    .attr("cx", d => d.x || 0)
                    .attr("cy", d => d.y || 0);

                labelElements
                    .attr("x", d => d.x || 0)
                    .attr("y", d => d.y || 0);

                edgeLabelElements
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);

            });
            /*.on("tick", () => {
                linkElements
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
    
                nodeElements
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
    
                labelElements
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
    
                /* edgeLabels
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2); */

            //});





        }



        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        function fitToGraph(svg, width, height) {
            const bounds = svg.node().getBBox();
            const fullWidth = bounds.width;
            const fullHeight = bounds.height;
            const midX = bounds.x + fullWidth / 2;
            const midY = bounds.y + fullHeight / 2;

            const scale = 0.85 / Math.max(fullWidth / width, fullHeight / height);
            const translate = [width / 2 - scale * midX, height / 2 - scale * midY];

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity.translate(...translate).scale(scale));
        }

        /*function focusOnNode(svg, nodeId, width, height) {
            const node = d3.select(`#node-${nodeId}`);
            if (!node.empty()) {
                const x = +node.attr("cx");
                const y = +node.attr("cy");
                const scale = 1.5;

                const translate = [width / 2 - scale * x, height / 2 - scale * y];
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(...translate).scale(scale));
            }
        }*/
        function focusOnNode(graph, nodeId, width, height) {
            const node = graph.simulation.nodes().find(n => n.id === nodeId);
            if (!node) return;

            // Mise en évidence (changer la couleur)
            
            graph.nodeGroup.selectAll("circle")
                .attr("stroke", d => d.id === nodeId ? "black" : null)
                .attr("stroke-width", d => d.id === nodeId ? 4 : null)
                .attr("fill", d => d.id === nodeId ? "limegreen" : (
                    d.group === 0 ? "orange" :
                        d.group === 1 ? "yellow" :
                            d.group === 2 ? "red" :
                                d.group === 3 ? "blue" : "lightgreen"
                ));
            
            // Zoom centré sur le nœud (vers le centre de l'écran)
            /*const newZoom = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(1.5)
                .translate(-node.x, -node.y);
*/
           /* graph.svg.transition().duration(750)
                .call(graph.zoom.transform,  d3.zoomIdentity.translate(-node.x, -node.y).scale(1.5));
                */
        }





        window.onload = function () {
            const container = document.getElementById("graph");
            network = new vis.Network(container, data, options);

            const graphe_svg = d3.select("#graph");//-----------------------------------------------------------------------------
            console.log("graphe_svg", graphe_svg.node());//--------------------------------------------------------------------------
            // Changement pour D3 network = new vis.Network(container, data, options);
            const graphCtx = drawGraph(container, data["nodes"], data["edges"]);
            window.graphPrincipal = graphCtx;
            //updateGraph(data.nodes, data.edges, svg, linkGroup, nodeGroup, labelGroup);

            //drawGraph(container, data["nodes"], data["edges"]);


            // -----------------EVENT LISTENER------------------- //    
            document.getElementById("resetView").addEventListener("click", () => {
                /*network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: "easeInOutQuad"
                    }
                });*/
                window.graphPrincipal.svg.transition().duration(750).call(
                    //zoom.transform,
                    window.graphPrincipal.zoom.transform,
                    d3.zoomIdentity // <-- transform de base : scale=1, translate=[0,0]
                );

                //fitToGraph(graphe_svg, graphe_svg.attr("width"), graphe_svg.attr("height"));//----------------------------------------------------

            });
            document.getElementById("resetPath").addEventListener("click", () => {
                //resetChemin(network);
                //-------------------------------------------------------------------------------------------------------------------
                data = {
                    nodes: [...path.nodes],
                    edges: [...path.edges]
                };

                updateGraph(data["nodes"], data["edges"],
                    window.graphPrincipal.svg,
                    window.graphPrincipal.linkGroup,
                    window.graphPrincipal.nodeGroup,
                    window.graphPrincipal.labelGroup,
                    window.graphPrincipal.edgeLabelGroup,
                    window.graphPrincipal.simulation,
                    window.graphPrincipal.zoomGroup);

                for (k of Object.keys(parent)) {
                    parent[k] = null;
                }
                liste_node_click = []
                // Recentrer après reset
                window.graphPrincipal.svg.transition().duration(750).call(
                    //zoom.transform,
                    window.graphPrincipal.zoom.transform,
                    d3.zoomIdentity // <-- transform de base : scale=1, translate=[0,0]
                );
                //fitToGraph(graphe_svg, graphe_svg.attr("width"), graphe_svg.attr("height"));
                path2_en_cours = false;
            });

            document.getElementById("ajouterGraph").addEventListener("click", () => {
                document.getElementById("modeAjoutGraph").innerHTML = 'Mode Ajout Graphe Activé';
                mode = "modeAjoutGraph";
                //resetChemin(network);
                //-------------------------------------------------------------------------------------------------------------------
                data = {
                    nodes: [...path.nodes],
                    edges: [...path.edges]
                };
                updateGraph(data["nodes"], data["edges"],
                    window.graphPrincipal.svg,
                    window.graphPrincipal.linkGroup,
                    window.graphPrincipal.nodeGroup,
                    window.graphPrincipal.labelGroup,
                    window.graphPrincipal.edgeLabelGroup,
                    window.graphPrincipal.simulation,
                    window.graphPrincipal.zoomGroup);
                for (k of Object.keys(parent)) {
                    parent[k] = null;
                }
                liste_node_click = []
                // Recentrer après reset
                fitToGraph(graphe_svg, graphe_svg.attr("width"), graphe_svg.attr("height"));
            });
            document.getElementById("echangerGraph").addEventListener("click", () => {
                document.getElementById("modeAjoutGraph").innerHTML = 'Mode Echange Graphe Activé';
                mode = "modeEchangeGraph";
                //resetChemin(network);
                //-------------------------------------------------------------------------------------------------------------------
                data = {
                    nodes: [...path.nodes],
                    edges: [...path.edges]
                };
                updateGraph(data["nodes"], data["edges"],
                    window.graphPrincipal.svg,
                    window.graphPrincipal.linkGroup,
                    window.graphPrincipal.nodeGroup,
                    window.graphPrincipal.labelGroup,
                    window.graphPrincipal.edgeLabelGroup,
                    window.graphPrincipal.simulation,
                    window.graphPrincipal.zoomGroup);
                for (k of Object.keys(parent)) {
                    parent[k] = null;
                }
                liste_node_click = []
                // Recentrer après reset
                fitToGraph(graphe_svg, graphe_svg.attr("width"), graphe_svg.attr("height"));
            });


            /* network.on("hoverNode", function (params) {
                 network.canvas.body.container.style.cursor = 'pointer'
             });
             network.on("blurNode", function (params) {
                 network.canvas.body.container.style.cursor = 'default';
             });
             network.on("showPopup", function (node) { })*/

            //network.on('click', function (properties) {
            graphe_svg.on('click', function (properties) {

                const user = document.getElementById("user").value;
                //var nodeId = network.getNodeAt({ x: properties.event.srcEvent.offsetX, y: properties.event.srcEvent.offsetY });

                //---------------------------------------------------------------------------------------------------------
                const [mouseX, mouseY] = d3.pointer(event);
                // Calculer distance par rapport à chaque nœud
                const clickedNode = data["nodes"].find(d => {
                    const dx = d.x - mouseX;
                    const dy = d.y - mouseY;
                    return Math.sqrt(dx * dx + dy * dy) < 10; // rayon toléré
                });
                if (clickedNode) {
                    console.log("Clicked node:", clickedNode);
                    var nodeId = clickedNode.id;
                }


                if (!nodeId) return
                if (!liste_node_click.includes(nodeId)) { // Si node jamais cliqué :
                    liste_node_click.push(nodeId) // ajouter dans liste

                    console.log("liste click :", liste_node_click);
                    console.log("afficher voisins !")
                    console.log("clic sur : ", nodeId);
                    console.log("parent dico : ", parent);

                    //var node = data.nodes.get(nodeId);

                    const checkboxes = document.querySelectorAll('.myCheckbox:checked');
                    const cb_predicates = Array.from(checkboxes).map(cb => cb.value);

                    if (cb_predicates.length > 0) {
                        //alert(`Cases cochées : ${cb_predicates.join(', ')}`);
                    } else {
                        //alert("Aucune case n'est cochée.");
                    }

                    fetch(`http://localhost:5000/api/pathETvoisins?start=${user}&end=${course}&voisin=${nodeId}&choix=${choix}`, { // Récuperer les voisins sortants de nodeId
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ predicates: cb_predicates })
                    })
                        .then(res => res.json())
                        .then(data2 => {
                            // Exclure les doublons de nœuds
                            const existingNodeIds = new Set(data.nodes.map(n => n.id));
                            console.log("data nodes : ", data2.nodes);
                            console.log("data edges : ", data2.edges);
                            console.log("already existing nodes : ", existingNodeIds);
                            console.log("path et voisins de ", nodeId, " : ", data2);
                            const newNodes = data2.nodes.filter(n => !existingNodeIds.has(n.id));
                            console.log("new nodes not in data actu :", newNodes);

                            // Mise à jour dict parent
                            for (n in newNodes) {
                                console.log("new nodes : ", newNodes[n].id);
                                parent[newNodes[n].id] = nodeId;

                            }
                            console.log("dico parent apres ajout enfant", parent);

                            // Exclure les doublons d'arêtes (selon from/to ou id si défini)
                            const existingEdgeKeys = new Set(data.edges.map(e => `${e.from}->${e.to}`));
                            const newEdges = data2.edges.filter(e => !existingEdgeKeys.has(`${e.from}->${e.to}`));
                            console.log("new edges not in data actu :", newEdges);

                            // Fusionner les données
                            newNodes.forEach(n => {
                                n.x = Math.random() * +600;
                                n.y = Math.random() * +600;
                            });
                            data = {
                                nodes: [...data.nodes, ...newNodes],
                                edges: [...data.edges, ...newEdges]
                            };


                            if (data2.nodes.length == 0) {
                                alert("Pas de voisins ! ");
                                liste_node_click.splice(liste_node_click.indexOf(nodeId), 1); // Retirer nodeId de la liste des nodes cliqués
                            }
                            console.log("liste click :", liste_node_click);

                            // Mettre à jour le graphe
                            //network.setData(data);
                            //---------------------------------------------------------------------------------------------------------
                            console.log("data avant update:", data);
                            console.log("data['nodes']:", data["nodes"]);

                            updateGraph(data["nodes"], data["edges"],
                                window.graphPrincipal.svg,
                                window.graphPrincipal.linkGroup,
                                window.graphPrincipal.nodeGroup,
                                window.graphPrincipal.labelGroup,
                                window.graphPrincipal.edgeLabelGroup,
                                window.graphPrincipal.simulation,
                                window.graphPrincipal.zoomGroup);

                        });
                } else { // Sinon, si node cliqué une seconde fois
                    console.log("liste click :", liste_node_click);
                    console.log("dico parents :", parent);
                    console.log("enfant : ", Object.keys(parent));
                    console.log("parent: ", Object.values(parent));

                    // Vérifier si ses noeuds voisins ont des noeuds sortants
                    var grandparent = 0;

                    for (k of Object.keys(parent)) {
                        //console.log("key : " + k);
                        if (parent[k] == nodeId && Object.values(parent).includes(k)) {
                            grandparent = 1;
                        }
                    }

                    if (grandparent == 0) {


                        liste_node_click.splice(liste_node_click.indexOf(nodeId), 1); // Retirer noeud de la liste des nodes cliqué

                        fetch(`http://localhost:5000/api/voisins?voisin=${nodeId}&choix=${choix}`) // Récuperer ses voisins pour les retirer
                            .then(res => res.json())
                            .then(data2 => {
                                console.log("retirer voisins de ", nodeId, " !");

                                // Récupérer les ids des voisins à retirer
                                const idsToRemove = new Set(data2.nodes.map(n => n.id));
                                const edgesToRemove = new Set(data2.edges.map(e => `${e.from}->${e.to}`));

                                // Construire un set des ids du chemin initial (path)
                                var pathNodeIds = new Set(path.nodes.map(n => n.id));
                                var pathEdge = new Set(path.edges.map(e => `${e.from}->${e.to}`));

                                if (path2_en_cours) { // Si on a ajouté au chemin initial d'autres chemins (mode ajout ou échange), prendre en consideration le total des chemins
                                    pathNodeIds = new Set(path2.nodes.map(n => n.id));
                                    pathEdge = new Set(path2.edges.map(e => `${e.from}->${e.to}`));
                                }

                                console.log("path 2 en cours : ", path2_en_cours);
                                console.log("path nodes : ", pathNodeIds);
                                console.log("path edges : ", pathEdge);
                                console.log("voisins : ", data2);
                                console.log("nodes à enlever : ", idsToRemove);

                                // Ne retirer que les noeuds qui sont dans idsToRemove mais PAS dans pathNodeIds
                                data = {
                                    nodes: data.nodes.filter(n => {
                                        // Retirer uniquement si le noeud est un voisin ET pas dans le chemin initial
                                        p = 0;
                                        for (k of Object.keys(parent)) {
                                            //console.log("key : " + k);
                                            if (parent[k] == n.id) {
                                                p = 1;
                                            }
                                        }
                                        if (idsToRemove.has(n.id) && !pathNodeIds.has(n.id) && p == 0) {
                                            parent[n.id] = null; // mettre à jour dict parent
                                            if (n.id in liste_node_click) {
                                                liste_node_click.splice(liste_node_click.indexOf(n.id), 1);
                                            }
                                            return false; // retirer
                                        }
                                        return true; // garder
                                    }),
                                    edges: data.edges.filter(e => {
                                        // Même logique pour les arêtes
                                        if (edgesToRemove.has(`${e.from}->${e.to}`) && !pathEdge.has(`${e.from}->${e.to}`)) {

                                            return false;
                                        }
                                        // arête pas dans edgesToRemove, on garde
                                        return true;
                                    })
                                };

                                console.log("data finale : ", data);

                                //si un element est dans liste node click mais n'est pas parent, le retirer : 
                                p = 0
                                for (n of liste_node_click) {
                                    for (k of Object.keys(parent)) {

                                        if (parent[k] == n) {
                                            p = 1;
                                        }
                                    }
                                    console.log("node check : " + n, " p= " + p);
                                }
                                if (p == 0) {
                                    liste_node_click.splice(liste_node_click.indexOf(n), 1); ///////////////////////////////////////////////////retirer aussi les edges ???????????????????????????????????????????????????????????????!!!!!!!!!!!!!!! A FAIRE
                                }

                                // Mettre à jour le graphe
                                //network.setData(data);
                                //--------------------------------------------------------------------------------------------------------------
                                updateGraph(
                                    data["nodes"],
                                    data["edges"],
                                    window.graphPrincipal.svg,
                                    window.graphPrincipal.linkGroup,
                                    window.graphPrincipal.nodeGroup,
                                    window.graphPrincipal.labelGroup,
                                    window.graphPrincipal.edgeLabelGroup,
                                    window.graphPrincipal.simulation,
                                    window.graphPrincipal.zoomGroup
                                );


                            });
                    } else {
                        alert("Clique d'abord sur les nodes enfants de celui-là !");

                    }
                }
            }
            )


            // --------------RECUPERATION DES PREDICATS AU DEBUT------------------ //
            fetch(`http://localhost:5000/api/predicats`)
                .then(res => res.json())
                .then(data2 => {

                    const container = document.getElementById("listPredicats");
                    const container2 = document.getElementById("cochePredicats");

                    console.log("all predicats : ", data2);

                    data2.forEach((p, i) => {
                        //console.log(p, i);

                        // Creation div predicat (à gauche en jaune, drag&drop)
                        const div = document.createElement("div");
                        div.className = "predicat";
                        liste = p.split("/");
                        div.innerHTML = liste[liste.length - 1];
                        div.id = liste[liste.length - 1];
                        div.draggable = "true";
                        div.ondragstart = dragstartHandler;
                        container.appendChild(div);

                        // Creation checkbox predicat en dessous du grand graph
                        const div2 = document.createElement("div");

                        const input = document.createElement("input");
                        input.type = "checkbox";
                        input.id = liste[liste.length - 1];
                        input.name = liste[liste.length - 1];
                        input.className = "myCheckbox";
                        input.value = liste[liste.length - 1];

                        const label = document.createElement("label");
                        label.for = liste[liste.length - 1];
                        label.appendChild(input);
                        label.innerHTML += liste[liste.length - 1];


                        div2.appendChild(label);
                        container2.appendChild(div2);

                        i += 1;
                    });

                })
        }


        // ------------------FONCTIONS COMPLEXES------------------- //

        function resetPredicats() { // Mettre à jour les prédicats (les enlever de la zone drop), mais aussi tout le reste (BUTTON REINITIALISER)

            // Vider le conteneur de prédicats dropés
            const dropZone = document.getElementById("div1");
            dropZone.innerHTML = "";
            document.getElementById("titre2").innerHTML = '';


            // Réinitialiser les variables globales
            choix = "false";
            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };
            parent = {};
            liste_node_click = [];

            // Nettoyer les graphes affichés
            //network.setData({ nodes: [], edges: [] });
            //-------------------------------------------------------------------
            updateGraph(data["nodes"], data["edges"],
                window.graphPrincipal.svg,
                window.graphPrincipal.linkGroup,
                window.graphPrincipal.nodeGroup,
                window.graphPrincipal.labelGroup,
                window.graphPrincipal.edgeLabelGroup,
                window.graphPrincipal.simulation,
                window.graphPrincipal.zoomGroup);

            document.getElementById("g_petit-container").innerHTML = "";
            document.getElementById("affichage-cours").innerHTML = "";
            document.getElementById("top5chart").innerHTML = "";
            top5ChartInstance.destroy();
            document.getElementById("titre2").innerHTML = "";

            // Vider et recharger les prédicats disponibles
            const predContainer = document.getElementById("listPredicats");
            predContainer.innerHTML = "";

            fetch(`http://localhost:5000/api/predicats`)
                .then(res => res.json())
                .then(preds => {
                    preds.forEach(p => {
                        const div = document.createElement("div");
                        const id = p.split("/").pop();
                        div.className = "predicat";
                        div.id = id;
                        div.draggable = true;
                        div.ondragstart = dragstartHandler;
                        div.innerHTML = id;
                        predContainer.appendChild(div);
                    });
                });


            //alert("Réinitialisation effectuée.");
        }


        function loadPath() { // Charger les chemins (BUTTON AFFICHER CHEMIN)

            const user = document.getElementById("user").value;
            parent = {}
            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };

            //Nettoyer les graphes affichés
            //network.setData(data);
            //------------------------------------------------------------------------------------------------
            updateGraph(data["nodes"], data["edges"],
                window.graphPrincipal.svg,
                window.graphPrincipal.linkGroup,
                window.graphPrincipal.nodeGroup,
                window.graphPrincipal.labelGroup,
                window.graphPrincipal.edgeLabelGroup,
                window.graphPrincipal.simulation,
                window.graphPrincipal.zoomGroup);

            document.getElementById("g_petit-container").innerHTML = "";

            fetch(`http://localhost:5000/api/random_course?start=${user}`)
                .then(res => res.json())
                .then(data4 => {
                    if (data4.error) {
                        alert(data4.error);
                        return;
                    }
                    course = data4.course;

                    const affichageDiv = document.getElementById("affichage-cours");
                    affichageDiv.innerHTML = `Cours recommandé : <strong>${course}</strong>`;

                    fetch(`http://localhost:5000/api/path?start=${user}&end=${course}&w=true&choix=${choix}`)
                        .then(res => res.json())
                        .then(data2 => {

                            // Mise à jour du graphe, du chemin principal et de l'explication textuelle
                            data = data2.path;
                            console.log('data :', data);
                            var texte = data2.texte;
                            document.getElementById('Explication').innerHTML = texte;
                            console.log("Path : ", data2);
                            path = {
                                nodes: [...data.nodes],
                                edges: [...data.edges]
                            };
                            console.log("chargement du path :", path);
                            //network.setData(data);
                            //----------------------------------------------------------------------------------------------------
                            updateGraph(data.nodes, data.edges,
                                window.graphPrincipal.svg,
                                window.graphPrincipal.linkGroup,
                                window.graphPrincipal.nodeGroup,
                                window.graphPrincipal.labelGroup,
                                window.graphPrincipal.edgeLabelGroup,
                                window.graphPrincipal.simulation,
                                window.graphPrincipal.zoomGroup);
                            // Ne lancer all_path que quand path a fini et retourné une réponse
                            const container = document.getElementById("g_petit-container");
                            container.innerHTML = "";  // Nettoyer l'ancien contenu
                            return fetch(`http://localhost:5000/api/all_path?start=${user}&end=${course}&w=true&choix=${choix}`);
                        })
                        .then(res => res.json())
                        .then(data2 => {
                            const container = document.getElementById("g_petit-container");

                            console.log("all paths from ", user, " to ", course, " : ", data2);
                            document.getElementById("titre2").innerHTML = "Autres chemins possibles";


                            data2.forEach((p, i) => {
                                // Création div où se trouvera le chemin + infos
                                const div = document.createElement("div");
                                div.className = "g_petit";
                                div.id = "g" + i;
                                container.appendChild(div);
                                const orderedNodes = orderNodesByEdges(p.nodes, p.edges);

                                const line = document.createElement("div");
                                line.innerHTML = "S_rw = " + p['S_rw'] + ", S_jac = " + p['S_jac'] + " --> " + p['S_final'];
                                container.appendChild(line);
                                const line2 = document.createElement("div");
                                line2.innerHTML = "Longueur = " + p['longueur'];
                                container.appendChild(line2);
                                const line3 = document.createElement("div");
                                line3.innerHTML = "Pattern : " + p['pattern'];
                                container.appendChild(line3);


                                // Création block de questions
                                const button_answer = document.createElement('button');
                                button_answer.className = 'button';
                                button_answer.id = 'buttonAnswer' + i;
                                button_answer.innerHTML = 'Answer';
                                container.appendChild(button_answer);


                                const div_questions = document.createElement("div");
                                div_questions.className = "divQuestions";
                                div_questions.id = "Questions" + i;
                                div_questions.style.display = "none";


                                var i_qt = 0;
                                const form = document.createElement('form');
                                for (elt of Object.keys(liste_question_possible)) {

                                    const div = document.createElement("div");
                                    div.innerHTML = elt;
                                    form.appendChild(div);

                                    for (qt of liste_question_possible[elt]) {
                                        var i_answer = 0;
                                        const question = document.createElement("div");
                                        question.innerHTML = '<strong>' + qt + '</strong>';
                                        form.appendChild(question);
                                        for (reponse of liste_answer_possible) {

                                            const input = document.createElement("input");
                                            input.type = "radio";
                                            input.id = 'answer' + i + (i_qt) + (i_answer++);
                                            input.name = 'answer' + i_qt;
                                            input.className = "myCheckbox";
                                            input.value = reponse;

                                            const label = document.createElement("label");
                                            label.htmlFor = input.id;
                                            label.appendChild(document.createTextNode(reponse));

                                            const wrapper = document.createElement("div");
                                            wrapper.className = "radioOption";
                                            wrapper.appendChild(input);
                                            wrapper.appendChild(label);

                                            form.appendChild(wrapper);
                                        }
                                        ++i_qt;
                                    }
                                }
                                div_questions.appendChild(form);

                                const button_valider = document.createElement('button');
                                button_valider.className = 'button';
                                button_valider.id = 'buttonValider' + i;
                                button_valider.innerHTML = 'Valider';
                                div_questions.appendChild(button_valider);

                                container.appendChild(div_questions);

                                // Event listener des boutons :
                                button_answer.addEventListener("click", () => {
                                    div_questions.style.display = "block"; // Afficher les questions
                                })

                                button_valider.addEventListener("click", () => {
                                    const questions = form.querySelectorAll("div > strong");
                                    let allAnswered = true;

                                    questions.forEach((qEl, index) => {
                                        const questionWrapper = qEl.parentElement;
                                        const radioName = 'answer' + index;
                                        const selected = form.querySelector(`input[name="${radioName}"]:checked`);

                                        // Supprime toute coloration rouge précédente
                                        qEl.style.color = "";

                                        if (!selected) {
                                            allAnswered = false;
                                            // Marque la question en rouge
                                            qEl.style.color = "red";
                                        }
                                    });

                                    if (allAnswered) {
                                        div_questions.style.display = "none"; // Ne plus afficher les qts
                                        button_answer.style.backgroundColor = '#9EBC8A';

                                        // récupération des réponses
                                        const responses = {};
                                        questions.forEach((qEl, index) => {
                                            const radioName = 'answer' + index;
                                            const selected = form.querySelector(`input[name="${radioName}"]:checked`);
                                            responses[radioName] = selected.value;
                                        });

                                        console.log("Réponses enregistrées :", responses);
                                        reponse_user_study['longueur/' + p['longueur'] + '/pattern/' + p['pattern']] = responses;
                                        console.log("Réponses totales :", reponse_user_study, ' keys:', Object.keys(reponse_user_study));
                                    } else {
                                        alert("Merci de répondre à toutes les questions.");
                                    }
                                });





                                // position des nodes horizontalement selon cet ordre
                                const spacedNodes = orderedNodes.map((node, i) => ({
                                    ...node,
                                    x: i * 150,  // espacement horizontal
                                    y: 0,
                                    fixed: { y: true }  // fixe seulement la coordonnée Y
                                }));


                                const customOptions = {
                                    ...options,
                                    nodes: {
                                        ...options.nodes,
                                        font: {
                                            ...options.nodes.font,
                                            size: 25  // nouvelle taille pour le texte des nœuds
                                        }
                                    },
                                    edges: {
                                        ...options.edges,
                                        font: {
                                            ...options.edges.font,
                                            size: 25  // nouvelle taille pour le texte des arêtes
                                        }
                                    },
                                    physics: {
                                        enabled: true  // si tu veux aussi désactiver la physique ici
                                    }
                                };

                                //a enlever !!!!!!!!!
                                /*var n = new vis.Network(div, {
                                    nodes: spacedNodes,
                                    edges: p.edges
                                }, customOptions);
                                */
                                //
                                //-------------------------------------------------------------------------------------???
                                //drawGraph(svg, p.nodes, p.edges);
                                drawGraph(div, orderedNodes, p.edges);

                                //n.on("showPopup", function (node) { });

                                // Si click sur un path --> l'ajouter dans le grand graphe si Mode ajout, sinon echanger path general par celui-ci
                                /*n.on('click', function (properties) {
                                    console.log("click path");
                                    pathNew = {
                                        nodes: [...orderedNodes],
                                        edges: [...p.edges]
                                    };
    
    
                                    if (mode == "modeAjoutGraph") {
                                        // Exclure les doublons de nœuds
                                        const existingNodeIds = new Set(data.nodes.map(n => n.id));
                                        const newNodes = pathNew.nodes.filter(n => !existingNodeIds.has(n.id));
    
                                        var existingNodeIdsInPath = new Set(path.nodes.map(n => n.id));
                                        var newNodesPath = pathNew.nodes.filter(n => !existingNodeIdsInPath.has(n.id));
                                        if (path2_en_cours) {
                                            existingNodeIdsInPath = new Set(path2.nodes.map(n => n.id));
                                            newNodesPath = pathNew.nodes.filter(n => !existingNodeIdsInPath.has(n.id));
                                        }
    
    
                                        // Exclure les doublons d'arêtes (selon from/to ou id si défini)
                                        const existingEdgeKeys = new Set(data.edges.map(e => `${e.from}->${e.to}`));
                                        const newEdges = pathNew.edges.filter(e => !existingEdgeKeys.has(`${e.from}->${e.to}`));
    
                                        var existingEdgeKeysInPath = new Set(path.edges.map(e => `${e.from}->${e.to}`));
                                        var newEdgesPath = pathNew.edges.filter(e => !existingEdgeKeysInPath.has(`${e.from}->${e.to}`));
                                        if (path2_en_cours) {
                                            existingEdgeKeysInPath = new Set(path2.edges.map(e => `${e.from}->${e.to}`));
                                            newEdgesPath = pathNew.edges.filter(e => !existingEdgeKeysInPath.has(`${e.from}->${e.to}`));
                                        }
    
                                        console.log("existing nodes  u:", existingNodeIds);
                                        console.log("existin edges u:", existingEdgeKeys);
                                        console.log("pathNew:", pathNew);
                                        console.log("new nodes :", newNodesPath);
                                        console.log("new edges :", newEdgesPath);
                                        console.log("new nodes utilisé :", newNodes);
                                        console.log("new edges utilisé:", newEdges);
                                        console.log("data : ", data);
    
                                        // Fusionner les données
                                        data = {
                                            nodes: [...data.nodes, ...newNodes],
                                            edges: [...data.edges, ...newEdges]
                                        };
    
                                        if (path2_en_cours) {
                                            path2 = {
                                                nodes: [...path2.nodes, ...newNodesPath],
                                                edges: [...path2.edges, ...newEdgesPath]
                                            };
                                        } else {
                                            path2 = {
                                                nodes: [...path.nodes, ...newNodesPath],
                                                edges: [...path.edges, ...newEdgesPath]
                                            };
                                        }
                                        console.log('path total :', path2);
    
    
                                    } else {
                                        // Remplacer
                                        data = {
                                            nodes: [...pathNew.nodes],
                                            edges: [...pathNew.edges]
                                        };
    
                                    }
                                    path2_en_cours = true;
    
                                    network.setData(data);
                                })*/
                            });
                        })
                    //.catch(err => alert("Erreur dans le chargement des chemins : " + err));

                    fetch(`http://localhost:5000/api/top5?user=${user}&course=${course}`)
                        .then(response => response.json())
                        .then(data => {
                            document.getElementById("messageTop5").innerText = "";
                            console.log("DEBUG top5 raw data:", data);
                            if (Object.keys(data).length == 0) {
                                console.log("Aucun attribut en commun");
                                document.getElementById("top5chart").style.display = "none";
                                document.getElementById("messageTop5").innerText = "Aucun attribut en commun";
                                return;
                            }
                            const labels = Object.keys(data).map(uri => uri.split("/").pop()); // simplifier les noms
                            const values = Object.values(data).map(Number);
                            console.log("top5 : ", data);
                            const ctx = document.getElementById('top5chart').getContext('2d');
                            if (top5ChartInstance !== null) {
                                top5ChartInstance.destroy();
                            }
                            top5ChartInstance = new Chart(ctx, {
                                type: 'bar',
                                data: {
                                    labels: labels,
                                    datasets: [{
                                        label: 'Pourcentage de similarité',
                                        data: values,
                                        backgroundColor: 'rgba(255, 251, 222, 0.7)',
                                        borderColor: '#ada56a',
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            max: 1
                                        }
                                    }
                                }
                            });
                            document.getElementById("top5chart").style.display = "block";  // réaffiche si caché
                            document.getElementById("messageTop5").innerText = "";
                        })
                        .catch(error => {
                            console.error("Erreur lors du chargement du top 5 :", error);
                        });

                })
                .catch(err => alert("Erreur lors de la récupération du cours aléatoire."));



        }



        function sendPredicatesToServer() { // Send prédicats pour ponderer le nouveau graphe (G_choix)

            const orderedPredicates = getOrderOfData("div1");
            console.log(orderedPredicates);

            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };

            /*network = new vis.Network(container, data, options);*/
            document.getElementById("g_petit-container").innerHTML = "";
            fetch("http://localhost:5000/api/predicats_ordonnés", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ predicates: orderedPredicates })
            })
                .then(response => response.json())
                .then(data => {
                    console.log("Réponse du serveur :", data);
                    alert("Prédicats envoyés avec succès !");
                    choix = "true";
                    console.log("choix : ", choix);
                })
                .catch(error => {
                    console.error("Erreur lors de l’envoi :", error);
                    alert("Erreur lors de l’envoi des prédicats.");
                });
        }


    </script>
</head>

<body>
    <!-- Conteneur principal à 3 colonnes -->
    <div id="main-layout" style="display: flex; flex-direction: column; height: 100vh;">

        <!-- Barre de navigation (optionnelle selon ta capture) -->
        <div id="nav-bar"
            style="display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #ccc;">
            <div>
                <h1>ExplainGraph </h1>
            </div>
            <div style="display: flex; flex: 1; overflow: hidden; padding-left: 20px;"><img src="./liris.png"
                    alt="Description de l'image" height="50"></div>
            <div style="display: flex; gap: 15px;">
                <a href="http://localhost:8000/page3.html">Accueil</a>
                <a href="https://liris.cnrs.fr/equipe/tweak">À propos</a>
                <a href="#">Export</a>
                <a href="http://localhost:8000">Paramètres</a>
            </div>
        </div>

        <!-- Zone de contenu principale -->
        <div id="content-area" style="display: flex; flex: 1; overflow: hidden;">

            <!-- Colonne de gauche : panneau de contrôle -->
            <div id="left-panel"
                style="flex: 0 0 300px; padding: 20px; overflow-y: auto; border-right: 1px solid #ccc;">
                <h3>Panneau de contrôle</h3>

                <label for="user">User</label>
                <input type="text" id="user" placeholder="user_xx" />

                <button class="button" onclick="loadPath()">Afficher le chemin</button>
                <button class="button" onclick="sendPredicatesToServer()">Appliquer prédicats</button>
                <button class="button" onclick="resetPredicats()">Réinitialiser</button>

                <div style="margin-top: 10px;">Drag & drop les prédicats les plus importants ci-dessous :</div>
                <div id="div1" ondrop="dropHandler(event)" ondragover="dragoverHandler(event)"
                    style="min-height: 60px; border: 1px dashed #999; margin: 10px 0;"></div>
                <div id="listPredicats" ondrop="dropHandler(event)" ondragover="dragoverHandler(event)"></div>
            </div>

            <!-- Colonne centrale : graphe et contrôles -->
            <div id="center-panel" style="flex: 1; padding: 20px; overflow-y: auto;">
                <div id="affichage-cours"></div>
                <h3>Chemin à partir d'un graphe pondéré</h3>

                <div class="graph-controls">
                    <button class="button" id="resetView">Recentrer le graphe</button>
                    <button class="button" id="resetPath">Réinitialiser chemin</button>
                    <input type="text" id="node" placeholder="course_xx, user_xx,..." />
                    <button class="button" onclick="chercherNode()">Chercher node</button>
                </div>

                <div>Cliquez sur un noeud pour étendre le graphe </div>

                <div id="graphs-container">
                    <div class="g" id="graph"></div>

                    <fieldset id="cochePredicats">
                        <legend>Choisis les prédicats que tu souhaites afficher (sortant du node cliqué)</legend>
                    </fieldset>
                </div>

                <div class="graph-controls">
                    <button class="button" id="ajouterGraph">Ajouter le chemin</button>
                    <button class="button" id="echangerGraph">Echanger le chemin</button>
                    <h3 id="modeAjoutGraph">Mode Ajout Graphe Activé</h3>
                </div>

                <h3 id="titre2"></h3>
                <div id="g_petit-container"></div>
            </div>

            <!--  Colonne de droite : explication + légende -->
            <div id="right-panel"
                style="flex: 0 0 500px; padding: 20px; overflow-y: auto; border-left: 1px solid #ccc;">
                <h3>Explication</h3>
                <p id="Explication">

                </p>

                <h4>Légende</h4>
                <ul style="list-style: none; padding-left: 0;">
                    <li><span
                            style="display: inline-block; width: 12px; height: 12px; background: rgb(236, 112, 90); border-radius: 50%; margin-right: 5px;"></span>
                        Topic</li>
                    <li><span
                            style="display: inline-block; width: 12px; height: 12px; background: rgb(67, 143, 206); border-radius: 50%; margin-right: 5px;"></span>
                        Utilisateur et Cours recommandé</li>
                    <li><span
                            style="display: inline-block; width: 12px; height: 12px; background: rgb(245, 221, 6); border-radius: 50%; margin-right: 5px;"></span>
                        Cours</li>
                    <li><span
                            style="display: inline-block; width: 12px; height: 12px; background: #bce98f; border-radius: 50%; margin-right: 5px;"></span>
                        Autre (type,creator, keyword, url, difficulty level, ...)</li>
                </ul>

                <h4>Top 5 Attributs</h4>
                <div id="messageTop5"></div>
                <canvas id="top5chart" width="260" height="200"></canvas>
            </div>
        </div>
    </div>
</body>


</html>