<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>

<head>
    <title>Accueil</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    /* ----------- RESET & BASE ----------- */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Segoe UI', sans-serif;
  background-color: #f7f9fc;
  color: #333;
  height: 100vh;
  overflow: hidden;
  font-size: 15px;
}

/* ----------- NAVIGATION ----------- */
#nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px 28px;
  background-color: #fff;
  border-bottom: 1px solid #e5e5e5;
  font-size: 18px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
}

#nav-bar a {
  text-decoration: none;
  color: #333;
  font-weight: 500;
  transition: color 0.3s;
}

#nav-bar a:hover {
  color: #2f80ed;
}

/* ----------- LAYOUT PRINCIPAL ----------- */
#content-area {
  display: flex;
  height: 100%;
}

/* ----------- PANNEAU DE CONTRÔLE (GAUCHE) ----------- */
#left-panel {
  flex: 0 0 280px;
  background-color: #ffffff;
  border-right: 1px solid #eee;
  padding: 24px;
  overflow-y: auto;
  box-shadow: inset -1px 0 0 #eee;
}

#left-panel h3 {
  font-size: 18px;
  margin-bottom: 16px;
  color: #444;
}

#left-panel label {
  display: block;
  margin-top: 16px;
  font-weight: 600;
  color: #555;
}

#left-panel input[type="text"],
#left-panel select {
  width: 100%;
  padding: 10px 12px;
  margin-top: 6px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fdfdfd;
  transition: border 0.3s;
}

#left-panel input:focus,
#left-panel select:focus {
  border-color: #2f80ed;
  outline: none;
}

/* ----------- BOUTONS ----------- */
.button {
  background-color: #2f80ed;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 14px;
  width: 100%;
  margin-top: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s, box-shadow 0.2s;
}

.button:hover {
  background-color: #1c60c3;
  box-shadow: 0 2px 8px rgba(47, 128, 237, 0.3);
}

/* ----------- DROP ZONES POUR PRÉDICATS ----------- */
#div1 {
  border: 2px dashed #bbb;
  border-radius: 8px;
  min-height: 80px;
  margin: 14px 0;
  padding: 12px;
  background-color: #fafbff;
  transition: border 0.3s;
}

#div1:hover {
  border-color: #2f80ed;
}

#listPredicats {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 10px;
}

#listPredicats .predicat {
  padding: 6px 10px;
  background-color: #f1cae9;
  color: #333;
  font-weight: bold;
  border-radius: 6px;
  border: 2px solid #9b4098;
  cursor: grab;
  font-size: 14px;
  user-select: none;
}

/* ----------- CENTRE : GRAPHE ----------- */
.graph-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
  align-items: center;
}

.graph-controls .button {
  flex: 0 0 auto;
  width: auto;
  padding: 10px 16px;
}

.graph-controls input[type="text"] {
  flex: 1;
  min-width: 180px;
  padding: 10px 12px;
  border: 1px solid #ccc;
  border-radius: 8px;
}

#center-panel {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
  background-color: #f9f9fb;
}

#g_petit-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-top: 20px;
}

.g {
  width: 100%;
  height: 600px;
  border: 3px solid #9b4098;
  background-color: #fff;
  border-radius: 20px;
  box-shadow: 0 2px 10px rgba(155, 64, 152, 0.1);
}

.g_petit {
  width: 45%;
  height: 200px;
  border: 3px solid #452272;
  background-color: #efecf2;
  border-radius: 16px;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.05);
}

/* ----------- DROITE - EXPLICATION ----------- */
#right-panel {
  flex: 0 0 300px;
  background-color: #ffffff;
  border-left: 1px solid #eee;
  padding: 24px;
  overflow-y: auto;
  box-shadow: inset 1px 0 0 #eee;
}

#right-panel h3 {
  font-size: 18px;
  margin-bottom: 10px;
  color: #444;
}

#right-panel p {
  font-size: 14px;
  margin-bottom: 24px;
  line-height: 1.6;
}

#right-panel h4 {
  font-size: 16px;
  margin-top: 20px;
  margin-bottom: 10px;
  color: #555;
}

#right-panel ul {
  list-style: none;
  padding-left: 0;
}

#right-panel li {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  font-size: 14px;
}

.legend-color {
  display: inline-block;
  width: 14px;
  height: 14px;
  margin-right: 8px;
  border-radius: 50%;
}

.legend-color.blue {
  background-color: #3b82f6;
}

.legend-color.gray {
  background-color: #6c757d;
}

/* ----------- RESPONSIVE ----------- */
@media (max-width: 1024px) {
  #content-area {
    flex-direction: column;
  }

  #left-panel,
  #right-panel {
    flex: none;
    width: 100%;
    border: none;
  }

  .g {
    height: 400px;
  }
}


    </style>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script>

        var color = "gray";
        let liste_node_click = []
        let top5ChartInstance = null;

        let parent = {}
        var len = undefined;
        var choix = "false";
        var path = { nodes: [], edges: [] };
        var data = { nodes: [], edges: [] };
        var course = "";
        const container = document.getElementById("graph");
        const options = {
            interaction: {
                hover: true,
            },
            physics: {
                enabled: true,
                solver: "repulsion",
                "barnesHut": {
                    "springConstant": 0,
                    "avoidOverlap": 2
                },
                repulsion: {
                    springLength: 500,
                    springConstant: 0.05,  // la constante de ressort
                    nodeDistance: 1000,
                    damping: 0.09,
                },
            },
            nodes: {
                shape: "dot",
                size: 30,
                font: { size: 40, color: "#420f31" },
                borderWidth: 2,
            },
            edges: {
                arrows: {
                    to: { enabled: true, scaleFactor: 1 }  // flèche vers le nœud 'to'
                },
                width: 1,
                font: { size: 35, align: "top", color: "#420f31" },

            },
        };







        window.onload = function () {
            const container = document.getElementById("graph");
            //const container2 = document.getElementById("graph2");




            network = new vis.Network(container, data, options);
            //network2 = new vis.Network(container2, data, options);

            document.getElementById("resetView").addEventListener("click", () => {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: "easeInOutQuad"
                    }
                });

            });
            document.getElementById("resetPath").addEventListener("click", () => {

                data = {
                    nodes: [...path.nodes],
                    edges: [...path.edges]
                };
                network.setData(data);
                for (k of Object.keys(parent)) {
                    parent[k] = null;
                }
                liste_node_click = []
                // Recentrer après reset
                network.fit({
                    animation: true
                });
            });
            network.on("hoverNode", function (params) {
                network.canvas.body.container.style.cursor = 'pointer'
            });
            network.on("blurNode", function (params) {
                network.canvas.body.container.style.cursor = 'default';
            });
            network.on("showPopup", function (node) { })
            //network2.on("showPopup", function(node) { })
            network.on('click', function (properties) {

                const user = document.getElementById("user").value;
                //const course = document.getElementById("course").value; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                var nodeId = network.getNodeAt({ x: properties.event.srcEvent.offsetX, y: properties.event.srcEvent.offsetY });
                if (!nodeId) return
                if (!liste_node_click.includes(nodeId)) {
                    liste_node_click.push(nodeId)
                    console.log("liste click :", liste_node_click);
                    console.log("afficher voisins !")



                    //var node = data.nodes.get(nodeId);
                    console.log("clic sur : ", nodeId);
                    console.log("parent dico : ", parent);


                    const checkboxes = document.querySelectorAll('.myCheckbox:checked');
                    const cb_predicates = Array.from(checkboxes).map(cb => cb.value);
                    if (cb_predicates.length > 0) {
                        //alert(`Cases cochées : ${cb_predicates.join(', ')}`);
                    } else {
                        //alert("Aucune case n'est cochée.");
                    }

                    /*fetch(`http://localhost:5000/api/pathETvoisins?start=${user}&end=${course}&voisin=${nodeId}&choix=${choix}`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ predicates: cb_predicates })
                    })
                        .then(res => res.json())
                        .then(data2 => {...})*/

                    fetch(`http://localhost:5000/api/pathETvoisins?start=${user}&end=${course}&voisin=${nodeId}&choix=${choix}`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ predicates: cb_predicates })
                    })
                        .then(res => res.json())
                        .then(data2 => {
                            //network = new vis.Network(container, data, options);

                            // Exclure les doublons de nœuds
                            const existingNodeIds = new Set(data.nodes.map(n => n.id));
                            console.log("data nodes : ", data2.nodes);
                            console.log("data edges : ", data2.edges);
                            console.log("already existing nodes : ", existingNodeIds);
                            console.log("path et voisins de ", nodeId, " : ", data2);
                            const newNodes = data2.nodes.filter(n => !existingNodeIds.has(n.id));
                            console.log("new nodes not in data actu :", newNodes);

                            // Mise à jour dict parent et dict grandparent !!!!!!!!!!!!!!!!!!!!!//////////////////////////////////////////////
                            for (n in newNodes) {
                                console.log("new nodes : ", newNodes[n].id);
                                parent[newNodes[n].id] = nodeId;
                                /*if (parent[nodeId] != null) {
                                    dic_node_grandparent[parent[nodeId]] = 1;
                                }*/
                            }
                            console.log("dico parent apres ajout enfant", parent);

                            // Exclure les doublons d'arêtes (selon from/to ou id si défini)
                            const existingEdgeKeys = new Set(data.edges.map(e => `${e.from}->${e.to}`));
                            const newEdges = data2.edges.filter(e => !existingEdgeKeys.has(`${e.from}->${e.to}`));
                            console.log("new edges not in data actu :", newEdges);

                            // Fusionner les données
                            data = {
                                nodes: [...data.nodes, ...newNodes],
                                edges: [...data.edges, ...newEdges]
                            };
                            if (data2.nodes.length == 0) {
                                alert("Pas de voisins ! ");
                                liste_node_click.splice(liste_node_click.indexOf(nodeId), 1);
                            }
                            console.log("liste click :", liste_node_click);

                            network.setData(data);

                        });
                } else {
                    console.log("liste click :", liste_node_click);
                    console.log("dico parents :", parent);
                    var grandparent = 0;
                    console.log("enfant : ", Object.keys(parent));
                    console.log("parent: ", Object.values(parent));
                    for (k of Object.keys(parent)) {
                        //console.log("key : " + k);
                        if (parent[k] == nodeId && Object.values(parent).includes(k)) {
                            grandparent = 1;
                        }
                    }

                    if (grandparent == 0) {


                        liste_node_click.splice(liste_node_click.indexOf(nodeId), 1);

                        fetch(`http://localhost:5000/api/voisins?voisin=${nodeId}&choix=${choix}`)
                            .then(res => res.json())
                            .then(data2 => {
                                console.log("retirer voisins de ", nodeId, " !");
                                // Récupérer les ids des voisins à retirer
                                const idsToRemove = new Set(data2.nodes.map(n => n.id));
                                const edgesToRemove = new Set(data2.edges.map(e => `${e.from}->${e.to}`));

                                // Construire un set des ids du chemin initial (path)
                                const pathNodeIds = new Set(path.nodes.map(n => n.id));
                                const pathEdge = new Set(path.edges.map(e => `${e.from}->${e.to}`));
                                console.log("path nodes : ", pathNodeIds);
                                console.log("voisins : ", data2);
                                console.log("nodes à enlever : ", idsToRemove);
                                // Ne retirer que les noeuds qui sont dans idsToRemove mais PAS dans pathNodeIds
                                data = {
                                    nodes: data.nodes.filter(n => {
                                        // Retirer uniquement si le noeud est un voisin ET pas dans le chemin initial
                                        p = 0;
                                        for (k of Object.keys(parent)) {
                                            //console.log("key : " + k);
                                            if (parent[k] == n.id) {
                                                p = 1;
                                            }
                                        }
                                        if (idsToRemove.has(n.id) && !pathNodeIds.has(n.id) && p == 0) {
                                            parent[n.id] = null; //////////////////////////////////////////////////////////////////////////////////////
                                            if (n.id in liste_node_click){
                                            liste_node_click.splice(liste_node_click.indexOf(n.id), 1);
                                            }
                                            return false; // retirer
                                        }
                                        return true; // garder
                                    }),
                                    edges: data.edges.filter(e => {
                                        // Même logique pour les arêtes
                                        if (edgesToRemove.has(`${e.from}->${e.to}`) && !pathEdge.has(`${e.from}->${e.to}`)) {

                                            return false;
                                        }
                                        // arête pas dans edgesToRemove, on garde
                                        return true;
                                    })
                                };
                                console.log("data finale : ", data);

                                //si un element est dans liste node clock mais n'est pas parent, le retirer : 
                                p = 0
                                for (n of liste_node_click) {
                                    for (k of Object.keys(parent)){
                                            
                                            if (parent[k] == n) {
                                                p = 1;
                                            }
                                        }
                                        console.log("node check : " + n," p= "+p);
                                    }
                                if (p==0){
                                    liste_node_click.splice(liste_node_click.indexOf(n), 1); ///////////////////////////////////////////////////retirer aussi les edges ???????????????????????????????????????????????????????????????!!!!!!!!!!!!!!! A FAIRE
                                }

                                network.setData(data);

                            });
                    } else {
                        alert("Clique d'abord sur les nodes enfants de celui-là !");

                    }
                }
            }
            )



            fetch(`http://localhost:5000/api/predicats`)
                .then(res => res.json())
                .then(data2 => {

                    const container = document.getElementById("listPredicats");
                    const container2 = document.getElementById("cochePredicats");

                    console.log("all predicats : ", data2);




                    data2.forEach((p, i) => {
                        //console.log(p, i);
                        const div = document.createElement("div");
                        div.className = "predicat";
                        liste = p.split("/");
                        div.innerHTML = liste[liste.length - 1];
                        div.id = liste[liste.length - 1];
                        div.draggable = "true";
                        div.ondragstart = dragstartHandler;
                        container.appendChild(div);

                        const div2 = document.createElement("div");

                        const input = document.createElement("input");
                        input.type = "checkbox";
                        input.id = liste[liste.length - 1];
                        input.name = liste[liste.length - 1];
                        input.className = "myCheckbox";
                        input.value = liste[liste.length - 1];

                        const label = document.createElement("label");
                        label.for = liste[liste.length - 1];
                        label.appendChild(input);
                        label.innerHTML += liste[liste.length - 1];


                        div2.appendChild(label);
                        container2.appendChild(div2);

                        i += 1;
                    });

                })





        }
        function resetPredicats() {
            // Vider le conteneur de prédicats dropés
            const dropZone = document.getElementById("div1");
            //top5ChartInstance = null;
            top5ChartInstance.destroy();
            
            dropZone.innerHTML = "";
            document.getElementById("titre2").innerHTML ='';

            // Réinitialiser les variables globales
            choix = "false";
            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };
            parent = {};
            liste_node_click = [];

            // Nettoyer les graphes affichés
            network.setData({ nodes: [], edges: [] });
            document.getElementById("g_petit-container").innerHTML = "";
            document.getElementById("affichage-cours").innerHTML = "";
            document.getElementById("top5chart").innerHTML = "";

            // Vider et recharger les prédicats disponibles
            const predContainer = document.getElementById("listPredicats");
            predContainer.innerHTML = "";

            fetch(`http://localhost:5000/api/predicats`)
                .then(res => res.json())
                .then(preds => {
                    preds.forEach(p => {
                        const div = document.createElement("div");
                        const id = p.split("/").pop();
                        div.className = "predicat";
                        div.id = id;
                        div.draggable = true;
                        div.ondragstart = dragstartHandler;
                        div.innerHTML = id;
                        predContainer.appendChild(div);
                    });
                });


            //alert("Réinitialisation effectuée.");
        }


        function loadPath() {
            parent = {}
            const user = document.getElementById("user").value;
            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };
            network.setData(data);
            document.getElementById("g_petit-container").innerHTML = "";
            //const course = document.getElementById("course").value;
            fetch(`http://localhost:5000/api/random_course?start=${user}`)
                .then(res => res.json())
                .then(data4 => {
                    if (data4.error) {
                        alert(data4.error);
                        return;
                    }
                    course = data4.course;

                    const affichageDiv = document.getElementById("affichage-cours");
                    affichageDiv.innerHTML = `Cours recommandé : <strong>${course}</strong>`;

                    fetch(`http://localhost:5000/api/path?start=${user}&end=${course}&w=true&choix=${choix}`)
                        .then(res => res.json())
                        .then(data2 => {
                            //network = new vis.Network(container, data, options);
                            data = data2;
                            console.log("Path : ", data2);
                            path = {
                                nodes: [...data2.nodes],
                                edges: [...data2.edges]
                            };
                            network.setData(data2);
                            // Ne lancer all_path que quand path a fini et retourné une réponse
                            const container = document.getElementById("g_petit-container");
                            container.innerHTML = "";  // Nettoyer l'ancien contenu
                            return fetch(`http://localhost:5000/api/all_path?start=${user}&end=${course}&w=true&choix=${choix}`);
                        })
                        .then(res => res.json())
                        .then(data2 => {
                            const container = document.getElementById("g_petit-container");

                            console.log("all paths from ", user, " to ", course, " : ", data2);
                            document.getElementById("titre2").innerHTML = "Autres chemins possibles";


                            data2.forEach((p, i) => {
                                const div = document.createElement("div");
                                div.className = "g_petit";
                                div.id = "g" + i;
                                container.appendChild(div);
                                const orderedNodes = orderNodesByEdges(p.nodes, p.edges);

                                // Maintenant positionne-les horizontalement selon cet ordre
                                const spacedNodes = orderedNodes.map((node, i) => ({
                                    ...node,
                                    x: i * 150,  // espacement horizontal
                                    y: 0,
                                    fixed: { y: true }  // fixe seulement la coordonnée Y
                                }));


                                const customOptions = {
                                    ...options,
                                    nodes: {
                                        ...options.nodes,
                                        font: {
                                            ...options.nodes.font,
                                            size: 25  // nouvelle taille pour le texte des nœuds
                                        }
                                    },
                                    edges: {
                                        ...options.edges,
                                        font: {
                                            ...options.edges.font,
                                            size: 25  // nouvelle taille pour le texte des arêtes
                                        }
                                    },
                                    physics: {
                                        enabled: true  // si tu veux aussi désactiver la physique ici
                                    }
                                };


                                var n = new vis.Network(div, {
                                    nodes: spacedNodes,
                                    edges: p.edges
                                }, customOptions);

                                //var n = new vis.Network(div, { 'nodes': p['nodes'], 'edges': p['edges'] }, options);
                                n.on("showPopup", function (node) { });

                                //container.innerHTML += "S_rw = " + p['S_rw'] + "<br>";

                                const line = document.createElement("div");
                                line.textContent = "S_rw = " + p['S_rw'] + ", S_jac = " + p['S_jac'] + " --> " + p['S_final'];
                                container.appendChild(line);

                            });
                        })
                        .catch(err => alert("Erreur dans le chargement des chemins : " + err));

                        fetch(`http://localhost:5000/api/top5?user=${user}&course=${course}`)
                        .then(response => response.json())
                        .then(data => {
                            document.getElementById("messageTop5").innerText = "";
                            console.log("DEBUG top5 raw data:", data);
                            if (Object.keys(data).length == 0) {
                                console.log("Aucun attribut en commun");
                                document.getElementById("top5chart").style.display = "none";
                                document.getElementById("messageTop5").innerText = "Aucun attribut en commun";
                                return;
                            }
                            const labels = Object.keys(data).map(uri => uri.split("/").pop()); // simplifier les noms
                            const values = Object.values(data).map(Number);
                            console.log("top5 : ", data);
                            const ctx = document.getElementById('top5chart').getContext('2d');
                            if (top5ChartInstance !== null) {
                                top5ChartInstance.destroy();
                            }
                            top5ChartInstance = new Chart(ctx, {
                                type: 'bar',
                                data: {
                                    labels: labels,
                                    datasets: [{
                                        label: 'Pourcentage de similarité',
                                        data: values,
                                        backgroundColor: 'rgba(54, 162, 235, 0.7)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            max: 1
                                        }
                                    }
                                }
                            });
                            document.getElementById("top5chart").style.display = "block";  // réaffiche si caché
                            document.getElementById("messageTop5").innerText = "";
                        })
                        .catch(error => {
                            console.error("Erreur lors du chargement du top 5 :", error);
                        });
                        
                })
                .catch(err => alert("Erreur lors de la récupération du cours aléatoire."))



        }


        function orderNodesByEdges(nodes, edges) {
            // Trouve le premier noeud (celui qui n'est pas dans 'to' d'une arête)
            const toNodes = new Set(edges.map(e => e.to));
            const fromNodes = new Set(edges.map(e => e.from));

            let startNode = nodes.find(n => !toNodes.has(n.id));
            if (!startNode) startNode = nodes[0]; // fallback

            const orderedNodes = [];
            let currentId = startNode.id;

            while (currentId !== undefined) {
                const currentNode = nodes.find(n => n.id === currentId);
                if (!currentNode) break;
                orderedNodes.push(currentNode);

                const nextEdge = edges.find(e => e.from === currentId);
                currentId = nextEdge ? nextEdge.to : undefined;
            }
            return orderedNodes;
        }



        function dragstartHandler(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
        }

        function dragoverHandler(ev) {
            if (ev.target.id == "div1" || ev.target.id == "listPredicats") {
                ev.preventDefault();
            }
        }

        function dropHandler(ev) {
            ev.preventDefault();
            const data3 = ev.dataTransfer.getData("text");
            ev.target.appendChild(document.getElementById(data3));
        }

        function InitGraph() {

        }
        function AfficheList(listId) {
            console.log(getOrderOfData(listId));
        }

        function sendPredicatesToServer() {

            const orderedPredicates = getOrderOfData("div1");
            console.log(orderedPredicates);

            path = { nodes: [], edges: [] };
            data = { nodes: [], edges: [] };

            /*network = new vis.Network(container, data, options);*/
            document.getElementById("g_petit-container").innerHTML = "";
            fetch("http://localhost:5000/api/predicats_ordonnés", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ predicates: orderedPredicates })
            })
                .then(response => response.json())
                .then(data => {
                    console.log("Réponse du serveur :", data);
                    alert("Prédicats envoyés avec succès !");
                    choix = "true";
                    console.log("choix : ", choix);
                })
                .catch(error => {
                    console.error("Erreur lors de l’envoi :", error);
                    alert("Erreur lors de l’envoi des prédicats.");
                });
        }





        function getOrderOfData(listId) {

            //get the list
            var list = document.getElementById(listId);


            var orderArray = [];
            var childs = list.children;
            for (var i = 0; i < childs.length; i++) {
                var child = childs[i];
                orderArray.push(child.id);
            }

            return orderArray;
        }


        function chercherNode() {
            const node = document.getElementById("node").value;
            console.log('node : ', node);
            for (n of data.nodes) {
                console.log('n :', n.label);
                if (n.label == node) {
                    network.focus(n.id, {
                        scale: 1.5, // Zoom level
                        animation: {
                            duration: 1000, // Animation duration in milliseconds
                            easingFunction: "easeInOutQuad", // Animation easing function
                        },
                    });
                    return
                }


            }
            alert("Node non trouvé");
            return
        }





    </script>
</head>

<body>
    <!-- Conteneur principal à 3 colonnes -->
    <div id="main-layout" style="display: flex; flex-direction: column; height: 100vh;">
  
      <!-- Barre de navigation (optionnelle selon ta capture) -->
      <div id="nav-bar" style="display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #ccc;">
        <div><strong>ExplainGraph</strong></div>
        <div style="display: flex; gap: 15px;">
          <a href="http://localhost:8000/page2.html">Accueil</a>
          <a href="https://liris.cnrs.fr/equipe/tweak">À propos</a>
          <a href="#">Export</a>
          <a href="http://localhost:8000">Paramètres</a>
        </div>
      </div>
  
      <!-- Zone de contenu principale -->
      <div id="content-area" style="display: flex; flex: 1; overflow: hidden;">
  
        <!-- 🔹 Colonne de gauche : panneau de contrôle -->
        <div id="left-panel" style="flex: 0 0 300px; padding: 20px; overflow-y: auto; border-right: 1px solid #ccc;">
          <h3>Panneau de contrôle</h3>
  
          <label for="user">User</label>
          <input type="text" id="user" placeholder="user_xx" />
  
          <button class="button" onclick="loadPath()">Afficher le chemin</button>
          <button class="button" onclick="sendPredicatesToServer()">Appliquer prédicats</button>
          <button class="button" onclick="resetPredicats()">Réinitialiser</button>
  
          <div style="margin-top: 10px;">Drag & drop les prédicats les plus importants ci-dessous :</div>
          <div id="div1" ondrop="dropHandler(event)" ondragover="dragoverHandler(event)" style="min-height: 60px; border: 1px dashed #999; margin: 10px 0;"></div>
          <div id="listPredicats" ondrop="dropHandler(event)" ondragover="dragoverHandler(event)"></div>
        </div>
  
        <!-- 🔹 Colonne centrale : graphe et contrôles -->
        <div id="center-panel" style="flex: 1; padding: 20px; overflow-y: auto;">
          <div id="affichage-cours"></div>
          <h3>Chemin à partir d'un graphe pondéré</h3>
  
          <div class="graph-controls">
            <button class="button" id="resetView">Recentrer le graphe</button>
            <button class="button" id="resetPath">Réinitialiser chemin</button>
            <input type="text" id="node" placeholder="course_xx, user_xx,..." />
            <button class="button" onclick="chercherNode()">Chercher node</button>
          </div>
  
          <div>Cliquez sur un noeud pour étendre le graphe </div>
  
          <div id="graphs-container">
            <div class="g" id="graph"></div>
  
            <fieldset id="cochePredicats">
              <legend>Choisis les prédicats que tu souhaites afficher (sortant du node cliqué)</legend>
            </fieldset>
          </div>
  
          <h3 id="titre2"></h3>
          <div id="g_petit-container"></div>
        </div>
  
        <!-- 🔹 Colonne de droite : explication + légende -->
        <div id="right-panel" style="flex: 0 0 500px; padding: 20px; overflow-y: auto; border-left: 1px solid #ccc;">
          <h3>Explication</h3>
          <p>
            Nous vous recommandons <strong>Objet D</strong> car il est populaire parmi des utilisateurs similaires
            et partage plusieurs tags avec vos films préférés.
          </p>
  
          <h4>Légende</h4>
          <ul style="list-style: none; padding-left: 0;">
            <li><span style="display: inline-block; width: 12px; height: 12px; background: rgb(246, 87, 59); border-radius: 50%; margin-right: 5px;"></span> Topic</li>
            <li><span style="display: inline-block; width: 12px; height: 12px; background: rgb(0, 127, 231); border-radius: 50%; margin-right: 5px;"></span> Utilisateur et Cours recommandé</li>
            <li><span style="display: inline-block; width: 12px; height: 12px; background: rgb(245, 221, 6); border-radius: 50%; margin-right: 5px;"></span> Cours</li>
        </ul>
  
          <h4>Top 5 Attributs</h4>
          <div id="messageTop5"></div>
          <canvas id="top5chart" width="260" height="200"></canvas>
        </div>
      </div>
    </div>
  </body>
  

</html>